from Crypto.Util.number import *
from secret import flag,e
m=bytes_to_long(flag)
p=getPrime(64)
q=getPrime(256)
n=p**4*q
k=getPrime(16)
gift=pow(e+114514+p**k,0x10001,p)
c=pow(m,e,n)

print(f'p={p}')
print(f'q={q}')
print(f'c={c}')
print(f'gift={gift}')

"""
p=14213355454944773291
q=61843562051620700386348551175371930486064978441159200765618339743764001033297
c=105002138722466946495936638656038214000043475751639025085255113965088749272461906892586616250264922348192496597986452786281151156436229574065193965422841
gift=9751789326354522940
"""
gift=pow(e+114514+p**k,0x10001,p)
gift=pow(e+114514,0x10001,p)

经计算e|phi,直接有限域开方的话e有点大，我们可以使用nth_root()来计算m，遍历一下nth_root的解即可找到flag

